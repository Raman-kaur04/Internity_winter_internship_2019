
#include <iostream>
#include <stack>
#include <algorithm>
#include <cstdlib>
using namespace std;

class Queue {
	stack<int> s1, s2;

public:
	
	void enqueue(int data)
	{
		s1.push(data);
	}

	
   int dequeue()
	{
		
		if (s1.empty() && s2.empty()) 
		{
			cout << "No element present!";
			exit(0);
		}

		
		if (s2.empty()) 
        {
			while (!s1.empty()) 
			{
				s2.push(s1.top());
				s1.pop();
			}
			
		}
        int top = s2.top();
		s2.pop();
		return top;
	}
};

int main()
{
	int keys[] = { 2, 4, 6, 8, 10 };
	Queue q;

	for (int i=0;i<5;i++) 
    {
		q.enqueue(keys[i]);
	}

	cout << q.dequeue() << '\n';	
	cout << q.dequeue() << '\n';   
	cout << q.dequeue() << '\n';
	cout << q.dequeue() << '\n';
	cout << q.dequeue() << '\n';

	return 0;
}


EXPLAINATION:

Implementation of queue using stack:
In this we have to implement the FIFO rule of queue using stacks. As we know that stack is LIFO and queue is FIFO, so we need two stacks to implement queue using stack.
For example: Suppose we push "1", "2", "3" to a stack. If we are trying to implement a queue and we call the dequeue method 3 times, we actually want the elements to come out in the order: "1", "2, "3", which is in the opposite order they would come out if we popped from the stack. So, basically, we need to access the elements in the reverse order that they exist in the stack. The following algorithm will implement a queue using two stacks.

1) When calling the enqueue method, simply push the elements into the stack.
Time complexity : O(1)  Space complexity: O(n)
2) If the dequeue method is called, push all the elements from stack1 to stack2, which reversed the order of elements.Now pop from stack 2.
Time complexity : O(n)  Space complexity: O(1)


So overall:
Time complexity: O(n)
Space complexity: O(n)
